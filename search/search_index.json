{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":""},{"location":"#welcome-to-django-microsoft-sso","title":"Welcome to Django Microsoft SSO","text":""},{"location":"#motivation","title":"Motivation","text":"<p>This library aims to simplify the process of authenticating users with Microsoft in Django Admin pages, inspired by libraries like django_microsoft_auth and django-admin-sso</p>"},{"location":"#why-another-library","title":"Why another library?","text":"<ul> <li> <p>This library aims for simplicity and ease of use. django-allauth is   de facto solution for Authentication in Django, but add lots of boilerplate, specially the html templates.   Django-Microsoft-SSO just add the \"Login with Microsoft\" button in the default login page.</p> Light ModeDark Mode <p></p> <p></p> </li> <li> <p>django_microsoft_auth is a bit outated but you can use it for old python and   django versions.</p> </li> <li>Microsoft provides a complete tutorial   here: https://learn.microsoft.com/en-us/training/modules/msid-django-web-app-sign-in/, with very good insights,   but it's a bit outdated and doesn't provide the social button.</li> </ul>"},{"location":"#install","title":"Install","text":"<pre><code>pip install django-microsoft-sso\n</code></pre> <p>Currently this project supports:</p> <ul> <li>Python 3.11, 3.12 and 3.13</li> <li>Django 4.2, 5.0, 5.1 and 5.2</li> </ul> <p>Older python/django versions are not supported.</p>"},{"location":"admin/","title":"Using Django Admin","text":"<p>Django Microsoft SSO integrates with Django Admin, adding an Inline Model Admin to the User model. This way, you can access the Microsoft SSO data for each user.</p>"},{"location":"admin/#blocking-password-authentication","title":"Blocking password authentication","text":"<p>Setting <code>SSO_SHOW_FORM_ON_ADMIN_PAGE=False</code> doesn't block the default admin site's password login api. For that you would need to override the default admin site's login method. Here is an example:</p> <pre><code>from typing import Any\n\nfrom django.conf import settings\nfrom django.contrib import admin\nfrom django.contrib.admin.apps import AdminConfig\nfrom django.http import HttpRequest, HttpResponse, HttpResponseNotAllowed\n\n\nclass MyAdminSite(admin.AdminSite):\n    ...\n\n    def login(\n        self, request: HttpRequest, extra_context: dict[str, Any] | None = None\n    ) -&gt; HttpResponse:\n       if request.method != \"GET\" and not settings.SSO_SHOW_FORM_ON_ADMIN_PAGE:\n            return HttpResponseNotAllowed([\"GET\"])\n        return super().login(request, extra_context)\n\n\nclass MyAdminConfig(AdminConfig):\n    default_site = \"path.to.MyAdminSite\"\n</code></pre> <p>See Django docs for more information on how to override the default admin site.</p>"},{"location":"admin/#using-custom-user-model","title":"Using Custom User model","text":"<p>If you are using a custom user model, you may need to add the <code>MicrosoftSSOInlineAdmin</code> inline model admin to your custom user model admin, like this:</p> <pre><code># admin.py\n\nfrom django.contrib import admin\nfrom django.contrib.auth.admin import UserAdmin\nfrom django_microsoft_sso.admin import (\n    MicrosoftSSOInlineAdmin, get_current_user_and_admin\n)\n\nCurrentUserModel, last_admin, LastUserAdmin = get_current_user_and_admin()\n\nif admin.site.is_registered(CurrentUserModel):\n    admin.site.unregister(CurrentUserModel)\n\n\n@admin.register(CurrentUserModel)\nclass CustomUserAdmin(LastUserAdmin):\n    inlines = (\n        tuple(set(list(last_admin.inlines) + [MicrosoftSSOInlineAdmin]))\n        if last_admin\n        else (MicrosoftSSOInlineAdmin,)\n    )\n</code></pre> <p>The <code>get_current_user_and_admin</code> helper function will return:</p> <ul> <li>the current registered UserModel in Django Admin (default: <code>django.contrib.auth.models.User</code>)</li> <li>the current registered UserAdmin in Django (default: <code>django.contrib.auth.admin.UserAdmin</code>)</li> <li>the instance of the current registered UserAdmin in Django (default: <code>None</code>)</li> </ul> <p>Use this objects to maintain previous inlines and register your custom user model in Django Admin.</p>"},{"location":"advanced/","title":"Advanced Use","text":""},{"location":"advanced/#using-custom-authentication-backend","title":"Using Custom Authentication Backend","text":"<p>If the users need to log in using a custom authentication backend, you can use the <code>MICROSOFT_SSO_AUTHENTICATION_BACKEND</code> setting:</p> <pre><code># settings.py\n\nMICROSOFT_SSO_AUTHENTICATION_BACKEND = \"myapp.authentication.MyCustomAuthenticationBackend\"\n</code></pre>"},{"location":"advanced/#using-microsoft-as-single-source-of-truth","title":"Using Microsoft as Single Source of Truth","text":"<p>If you want to use Microsoft as the single source of truth for your users, you can simply set the <code>MICROSOFT_SSO_ALWAYS_UPDATE_USER_DATA</code>. This will enforce the basic user data (first name, last name, email and picture) to be updated at every login.</p> <pre><code># settings.py\n\nMICROSOFT_SSO_ALWAYS_UPDATE_USER_DATA = True  # Always update user data on login\n</code></pre> <p>If you need more advanced logic, you can use the <code>MICROSOFT_SSO_PRE_LOGIN_CALLBACK</code> setting to import custom data from Microsoft (considering you have configured the right scopes and possibly a Custom User model to store these fields).</p> <p>For example, you can use the following code to update the user's name, email and birthdate at every login:</p> <pre><code># settings.py\n\nMICROSOFT_SSO_SAVE_ACCESS_TOKEN = True  # You will need this token\nMICROSOFT_SSO_PRE_LOGIN_CALLBACK = \"hooks.pre_login_user\"\nMICROSOFT_SSO_SCOPES = [\n    \"User.Read.All\" # &lt;-- custom scope to get all user basic data\n]\n</code></pre> <pre><code># myapp/hooks.py\nimport datetime\nimport httpx\nfrom loguru import logger\n\n\ndef pre_login_user(user, request):\n    token = request.session.get(\"microsoft_sso_access_token\")\n    if token:\n        headers = {\n            \"Authorization\": f\"Bearer {token}\",\n        }\n\n        # Request Microsoft User Info\n        url = \"https://graph.microsoft.com/v1.0/me/\"\n        response = httpx.get(url, headers=headers)\n        user_data = response.json()\n        logger.debug(f\"Updating User Data with Microsoft User Info: {user_data}\")\n\n        user.first_name = user_data[\"givenName\"]\n        user.last_name = user_data[\"surname\"]\n        user.email = user_data[\"mail\"]\n        user.birthdate = user_data.get(\"birthday\")  # You need a Custom User model to store this field\n        user.save()\n</code></pre>"},{"location":"callback/","title":"Get your Callback URI","text":"<p>The callback URL is the URL where your Microsoft Entra Registered Application will redirect the user after the authentication process. This URL must be registered in your Registered Application.</p>"},{"location":"callback/#the-callback-uri","title":"The Callback URI","text":"<p>The callback URI is composed of <code>{scheme}://{netloc}/{path}/</code>, where the netloc is the domain name of your Django project, and the path is <code>/microsoft_sso/callback/</code>. For example, if your Django project is hosted on <code>https://myproject.com</code>, then the callback URL will be <code>https://myproject.com/microsoft_sso/callback/</code>.</p> <p>So, let's break each part of this URI:</p>"},{"location":"callback/#the-scheme","title":"The scheme","text":"<p>The scheme is the protocol used to access the URL. It can be <code>http</code> or <code>https</code>. Django-Microsoft-SSO will select the same scheme used by the URL which shows to you the login page.</p> <p>For example, if you're running locally, like <code>http://localhost:8000/accounts/login</code>, then the callback URL scheme will be <code>http://</code>.</p> How about a Reverse-Proxy? <p>If you're running Django behind a reverse-proxy, please make sure you're passing the correct <code>X-Forwarded-Proto</code> header to the login request URL.</p>"},{"location":"callback/#the-netloc","title":"The NetLoc","text":"<p>The NetLoc is the domain of your Django project. It can be a dns name, or an IP address, including the Port, if needed. Some examples are: <code>example.com</code>, <code>localhost:8000</code>, <code>api.my-domain.com</code>, and so on. To find the correct netloc, Django-Microsoft-SSO will check, in that order:</p> <ul> <li>If settings contain the variable <code>MICROSOFT_SSO_CALLBACK_DOMAIN</code>, it will use this value.</li> <li>If Sites Framework is active, it will use the domain field for the current site.</li> <li>The netloc found in the URL which shows you the login page.</li> </ul>"},{"location":"callback/#the-path","title":"The Path","text":"<p>The path is the path to the callback view. It will be always <code>/&lt;path in urls.py&gt;/callback/</code>.</p> <p>Remember when you add this to the <code>urls.py</code>?</p> <pre><code>from django.urls import include, path\n\nurlpatterns = [\n    # other urlpatterns...\n    path(\n        \"microsoft_sso/\", include(\n            \"django_microsoft_sso.urls\",\n            namespace=\"django_microsoft_sso\"\n        )\n    ),\n]\n</code></pre> <p>The path starts with the <code>microsoft_sso/</code> part. If you change this to <code>sso/</code> for example, your callback URL will change to <code>https://myproject.com/sso/callback/</code>.</p>"},{"location":"callback/#registering-the-uri","title":"Registering the URI","text":"<p>Navigate to the App registrations page, select your Registered Application and navigate to Authentication.</p> <p>On Platform configurations, if you don't have any platform configured, click on Add a platform and select Web.</p> <p></p> <p>To register the callback URL, add the callback URL in the Redirect URIs field, clicking on button <code>Add URI</code>. Then add your full URL and click on <code>Configure</code>.</p> <p></p> <p>Do not forget the trailing slash</p> <p>Many errors on this step are caused by forgetting the trailing slash:</p> <ul> <li>Good: <code>http://localhost:8000/microsoft_sso/callback/</code></li> <li>Bad: <code>http://localhost:8000/microsoft_sso/callback</code></li> </ul>"},{"location":"callback/#single-logout-from-microsoft","title":"Single Logout (from Microsoft)","text":"<p>To configure SLO (Single Logout), starting from Microsoft (logout from Microsoft first then logout from your Project) - you can optionally add Django logout URL in the Web Platform configurations. But you must inform a https address:</p> <p></p> <p>During development, use an instant ingress tunnel service for this</p> <p>Ngrok is an excellent service to redirect a https connection to your local development server.</p> <p>In the next step, we will configure Django-Microsoft-SSO to auto create the Users.</p>"},{"location":"credentials/","title":"Adding Microsoft Credentials","text":"<p>To make the SSO work, we need to set up, in your Django project, you need the credentials from your Microsoft Entra Registered Application.</p> <p>Microsoft is a huge company that works for even larger ones. This means that the Microsoft Entra Platform is very complex and can be a bit confusing for newcomers. The following sections provide a brief overview of the Microsoft Entra Platform and the key concepts that are relevant to the authentication process. You do not need to understand all the details, but it is important to have a general idea of how the different components fit, especially when you need to configure and troubleshoot your application.</p>"},{"location":"credentials/#understand-microsoft-tenants","title":"Understand Microsoft Tenants","text":"<p>Microsoft Entra, formerly known as Azure Active Directory (Azure AD), organizes user access and resources through a unique entity known as a Tenant. A tenant represents a dedicated instance of Microsoft Entra ID, essentially serving as a directory of users and groups that is owned and managed by an organization. Each tenant is distinct and separate from other tenants, ensuring data privacy and security across the Microsoft Cloud environment.</p> <p>What the Tenant means to your Organization?</p> <p>The tenant can be your entire company, a business unit or even a single department. It is a security boundary that defines the scope of administrative authority for an organization.</p> <p>The most important thing to understand here is while you can restrict or permit data to be shared between entities inside a tenant, you are not allowed to share data between them.</p>"},{"location":"credentials/#understand-the-registered-enterprise-application","title":"Understand the Registered Enterprise Application","text":"<p>To your projects can interact with your Tenants, you will need to register an Enterprise Application:</p>"},{"location":"credentials/#registered-application","title":"Registered Application","text":"<p>Registering an application in Microsoft Entra informs the platform about the application's existence and defines the interaction parameters between the platform and the projects which will access it through the application. The registration encompasses details like the application's name, type (e.g., web, public, native), redirect URIs, client identifiers, client secrets, and other settings controlling the interaction with the identity service.</p>"},{"location":"credentials/#enterprise-application","title":"Enterprise Application","text":"<p>Once registered, the application can be utilized across one or more Microsoft Entra tenants. A registered application is referred to an \"Enterprise Application\" for the purpose of the configurations the application needs regard a tenant, covering aspects like who can use the application, the permissions it holds, monitoring, auditing, and more.</p>"},{"location":"credentials/#single-or-multi-tenant-applications","title":"Single or Multi-tenant Applications","text":"<p>The distinction between single-tenant and multi-tenant configurations is important for understanding how applications interact with user identities and resources within the Microsoft Entra ecosystem. In a single-tenant configuration, the application is registered within a specific tenant, ensuring that only users from that particular tenant can authenticate. On the other hand, a multi-tenant configuration allows an application to be available to users across multiple tenants. This setup facilitates broader access and interoperability, catering to scenarios where an application needs to be accessible to users from different organizational domains.</p> <p>What the Registered Enterprise Application means to your Organization?</p> <p>This can be a single application to handle all users, from all tenants to all projects you want to authenticate. Or can be a complex multiple applications for multi-tenant and multiple projects/environments. The final organization depends on your company compliance needs.</p> <p>The most important thing here is while you can start with just One-App-to-Rule-All, you will eventually finish with a configuration which embraces your company needs. Do not underestimate this task.</p> <p>To learn more:</p> <ul> <li>Multi-tenant user management introduction</li> <li>Single and Multi Tenants Apps</li> <li>OAuth 2.0 and OpenID Connect (OIDC) in the Microsoft identity platform</li> </ul>"},{"location":"credentials/#creating-your-first-microsoft-entra-registered-application","title":"Creating your first Microsoft Entra Registered Application","text":"<p>To create your first Microsoft Entra Registered Application, you need to access the Microsoft Entra Administration Center and navigate to Applications -&gt; App registrations.</p> <p>For the purpose of this tutorial, we suggest creating a new registered application, clicking on the New registration button.</p> Do I use an existing application or create a new one? <p>The decision to use an existing Application or create a new one depends on your needs: you can create an application for each project you have, for each group of users, or for each environment (development, staging, production, etc...).</p> <p>The safest route is to create a new single-tenant application for each project for each environment. This helps to mitigate the risk of exposing all your data in case of a security breach and the risk of service interruption due to misconfiguration. But in the other hand, this can be a bit cumbersome and fairly complex to manage.</p> <p>In the end, any solution must be compatible with how your organization works.</p> <p>Navigate to the App registrations page and click on the New registration button.</p> <p></p> <p>Add a new name for the app, and select the Supported account types to Accounts in this organizational directory only.</p> <p></p> <p>Go back to the Overview tab and retrieve the Application (client) ID. This will be the <code>MICROSOFT_SSO_APPLICATION_ID</code> in your Django project.</p> <p></p> <p>Now, navigate to the Certificates &amp; secrets tab and click on the New client secret button. Add a description for the secret and select the expiration date. Click on the Add button.</p> <p></p> <p>In the next page, copy the Value of the secret. This will be the <code>MICROSOFT_SSO_CLIENT_SECRET</code> in your Django project.</p> <p></p> <p>Navigate to Enterprise applications, select your application and go  to the Users and Groups tab and add a test user to your application.</p> <p></p>"},{"location":"credentials/#configuring-your-django-project","title":"Configuring your Django Project","text":"<p>After that, add the credentials in your <code>settings.py</code> file:</p> <pre><code># settings.py\nMICROSOFT_SSO_APPLICATION_ID = \"your Application (client) Id here\"\nMICROSOFT_SSO_CLIENT_SECRET = \"your client secret value here\"\n</code></pre> <p>Don't commit this info in your repository. This permits you to have different credentials for each environment and mitigates security breaches. That's why we recommend you to use environment variables to store this info. To read this data, we recommend you to install and use a Twelve-factor compatible library in your project.</p> <p>For example, you can use our project Stela to load the environment variables from a <code>.env.local</code> file, like this:</p> <pre><code># .env.local\nMICROSOFT_SSO_APPLICATION_ID = \"your Application (client) Id here\"\nMICROSOFT_SSO_CLIENT_SECRET = \"your client secret value here\"\n</code></pre> <pre><code># Django settings.py\nfrom stela import env\n\nMICROSOFT_SSO_APPLICATION_ID = env.MICROSOFT_SSO_APPLICATION_ID\nMICROSOFT_SSO_CLIENT_SECRET = env.MICROSOFT_SSO_CLIENT_SECRET\n</code></pre> <p>But in fact, you can use any library you want, like django-environ, django-constance, python-dotenv, etc...</p>"},{"location":"credentials/#customizing-token-authority","title":"Customizing Token Authority","text":"<p>By default, Django Microsoft SSO uses the default Token Authority from the <code>microsoft-authentication-library-for-python</code> library (msal). Currently, the default Token Authority is <code>https://login.microsoftonline.com/common</code>.</p> <p>If you need to define another authority, please set the <code>MICROSOFT_SSO_AUTHORITY</code> option with your full tenant URL or <code>AuthorityBuilder</code> instance.</p>"},{"location":"credentials/#using-a-custom-authority-url","title":"Using a custom authority URL","text":"<p>Please inform the full URL of your tenant, like <code>https://login.microsoftonline.com/your_tenant</code>.</p> <pre><code># settings.py\n\nMICROSOFT_SSO_AUTHORITY = \"https://login.microsoftonline.com/your_tenant\"\n</code></pre>"},{"location":"credentials/#using-a-custom-authority-with-authoritybuilder","title":"Using a custom authority with AuthorityBuilder","text":"<p>Use the <code>AuthorityBuilder</code> class to create a custom authority. This class is available in the <code>msal</code> library.</p> <pre><code># settings.py\n\nfrom msal.authority import (\n    AuthorityBuilder,\n    AZURE_US_GOVERNMENT, AZURE_CHINA, AZURE_PUBLIC\n)\n\nMICROSOFT_SSO_AUTHORITY = AuthorityBuilder(AZURE_PUBLIC, \"your-tenant.onmicrosoft.com\")\n</code></pre> <p>To learn more:</p> <ul> <li>MSAL Client Application Configuration Options</li> <li>Microsoft Authentication Library (MSAL) for Python</li> </ul> <p>In the next step, we need to configure the authorized callback URI for your Django project.</p>"},{"location":"customize/","title":"Customizing the Login Page","text":"<p>Below, you can find some tips on how to customize the login page.</p>"},{"location":"customize/#hiding-the-login-form","title":"Hiding the Login Form","text":"<p>If you want to show only the Microsoft Login button, you can hide the login form using the <code>SSO_SHOW_FORM_ON_ADMIN_PAGE</code> setting.</p> <pre><code># settings.py\n\nSSO_SHOW_FORM_ON_ADMIN_PAGE = False\n</code></pre>"},{"location":"customize/#customizing-the-login-button","title":"Customizing the Login button","text":"<p>Customizing the Login button is very simple. For the logo and text change is straightforward, just inform the new values. For the style, you can override the css file.</p>"},{"location":"customize/#the-button-logo","title":"The button logo","text":"<p>To change the logo, use the <code>MICROSOFT_SSO_BUTTON_LOGO</code> setting.</p> <pre><code># settings.py\nMICROSOFT_SSO_LOGO_URL = \"https://example.com/logo.png\"\n</code></pre>"},{"location":"customize/#the-button-text","title":"The button text","text":"<p>To change the text, use the <code>MICROSOFT_SSO_BUTTON_TEXT</code> setting.</p> <pre><code># settings.py\n\nMICROSOFT_SSO_TEXT = \"New login message\"\n</code></pre>"},{"location":"customize/#the-button-style","title":"The button style","text":"<p>The login button css style is located at <code>static/django_microsoft_sso/microsoft_button.css</code>. You can override this file as per Django static files documentation.</p>"},{"location":"customize/#an-example","title":"An example","text":"<pre><code># settings.py\n\nMICROSOFT_SSO_TEXT = \"Login using Microsoft 365 Account\"\n</code></pre> <pre><code>/* static/django_microsoft_sso/microsoft_button_custom.css */\n\n/* other css... */\n\n.microsoft-login-btn {\n    background-color: darkcyan;\n    border: 1px solid #a7a7a7;\n    padding: 1px;\n    margin-bottom: 10px;\n    width: 100%;\n}\n</code></pre> <p>The result:</p> <p></p>"},{"location":"how/","title":"How Django Microsoft SSO works?","text":""},{"location":"how/#current-flow","title":"Current Flow","text":"<ol> <li> <p>First, the user is redirected to the Django login page. If settings <code>MICROSOFT_SSO_ENABLED</code> is True, the \"Login with Microsoft\" button will be added to a default form.</p> </li> <li> <p>On click, Django-Microsoft-SSO will add, in a anonymous request session, the <code>sso_next_url</code> and Microsoft Auth info. This data will expire in 10 minutes. Then user will be redirected to Microsoft login page.</p> <p>Using Request Anonymous session</p> <p>If you make any actions which change or destroy this session, like restart django, clear cookies or change browsers, ou move between <code>localhost</code> and <code>127.0.0.1</code>, the login will fail, and you can see the message \"State Mismatched. Time expired?\" in the next time you log in again. Also remember the anonymous session lasts for 10 minutes, defined in<code>MICROSOFT_SSO_TIMEOUT</code>.</p> </li> <li> <p>On callback, Django-Microsoft-SSO will check <code>code</code> and <code>state</code> received. If they are valid, Microsoft's UserInfo will be retrieved. If the user is already registered in Django, the user will be logged in. The Graph request has a timeout of 10 seconds, defined in <code>MICROSOFT_SSO_GRAPH_TIMEOUT</code>.</p> </li> <li> <p>Otherwise, the user will be created and logged in, if his email domain, matches one of the <code>MICROSOFT_SSO_ALLOWABLE_DOMAINS</code>. You can disable the auto-creation setting <code>MICROSOFT_SSO_AUTO_CREATE_USERS</code> to False.</p> </li> <li> <p>On creation only, this user can be set to the<code>staff</code> or <code>superuser</code> status, if his email are in <code>MICROSOFT_SSO_STAFF_LIST</code> or <code>MICROSOFT_SSO_SUPERUSER_LIST</code> respectively. Please note if you add an email to one of these lists, the email domain must be added to <code>MICROSOFT_SSO_ALLOWABLE_DOMAINS</code>too.</p> </li> <li> <p>This authenticated session will expire in 1 hour, or the time defined, in seconds, in <code>MICROSOFT_SSO_SESSION_COOKIE_AGE</code>.</p> </li> <li> <p>If login fails, you will be redirected to route defined in <code>MICROSOFT_SSO_LOGIN_FAILED_URL</code> (default: <code>admin:index</code>) which will use Django Messaging system to show the error message.</p> </li> <li> <p>If login succeeds, the user will be redirected to the <code>next_path</code> saved in the anonymous session, or to the route defined in <code>MICROSOFT_SSO_NEXT_URL</code> (default: <code>admin:index</code>) as a fallback.</p> </li> </ol>"},{"location":"how/#the-define_sso_providers-template-tag","title":"The <code>define_sso_providers</code> template tag","text":"<p>Django-Microsoft-SSO uses this tag to define which buttons to show on the login page. This is because the same tag is used in other libraries, like django-google-sso and django-github-sso. This tag checks the <code>*_SSO_ENABLED</code>, <code>*_SSO_ADMIN_ENABLED</code> and <code>*_SSO_PAGES_ENABLED</code> settings to return a list of enabled SSO providers for the current request.</p> <p>if you need to customize this, you can pass in the request context the <code>sso_providers</code> variable with a list of providers to show, like this:</p> <pre><code># views.py\nfrom django.shortcuts import render\n\ndef my_view(request):\n    ...\n    sso_providers = [\n        {\n            \"name\": \"Microsoft\",\n            \"logo_url\": \"...\", # URL for the button logo\n            \"text\": \"...\",  # Text for the button\n            \"login_url\": \"...\",  # URL to redirect to start the login flow\n            \"css_url\": \"...\",  # URL for the button CSS\n         }\n    ]\n    return render(request, \"my_login_template.html\", {\"sso_providers\": sso_providers})\n</code></pre> <p>Also, if you're using async views, you can run the original template tags, like this:</p> <pre><code># views.py\nfrom django.shortcuts import render\nfrom django_microsoft_sso.utils import adefine_sso_providers, adefine_show_form\n\nasync def my_async_view(request):\n    ...\n    context = {\n        \"show_admin_form\": await adefine_show_form(request),\n        \"sso_providers\": await adefine_sso_providers(request)\n    }\n    return render(request, \"my_login_template.html\", context)\n</code></pre> <p>The same is valid for define_show_form tag</p> <p>You can pass in the request context the <code>show_admin_form</code> variable with a boolean value to show or hide the default login form.</p>"},{"location":"model/","title":"Getting Microsoft info","text":""},{"location":"model/#the-user-model","title":"The User model","text":"<p>Django Microsoft SSO saves in the database the following information from Microsoft, using current <code>User</code> model:</p> <ul> <li><code>email</code>: The email address of the user.</li> <li><code>first_name</code>: The first name of the user.</li> <li><code>last_name</code>: The last name of the user.</li> <li><code>username</code>: The email address of the user.</li> <li><code>password</code>: An unusable password, generated using <code>get_unusable_password()</code> from Django.</li> </ul> <p>Getting data on code is straightforward:</p> <pre><code>from django.contrib.auth.decorators import login_required\nfrom django.http import JsonResponse, HttpRequest\n\n@login_required\ndef retrieve_user_data(request: HttpRequest) -&gt; JsonResponse:\n    user = request.user\n    return JsonResponse({\n        \"email\": user.email,\n        \"first_name\": user.first_name,\n        \"last_name\": user.last_name,\n        \"username\": user.username,\n    })\n</code></pre>"},{"location":"model/#the-microsoftssouser-model","title":"The MicrosoftSSOUser model","text":"<p>Also, on the <code>MicrosoftSSOUser</code> model, it saves the following information:</p> <ul> <li><code>picture_raw</code>: The binary data of the user's profile picture.</li> <li><code>microsoft_id</code>: The Microsoft Entra ID of the user.</li> <li><code>locale</code>: The preferred locale of the user.</li> </ul> <p>This is a one-to-one relationship with the <code>User</code> model, so you can access this data using the <code>microsoftssouser</code> reverse relation attribute:</p> <pre><code>from django.contrib.auth.decorators import login_required\nfrom django.http import JsonResponse, HttpRequest\n\n@login_required\ndef retrieve_user_data(request: HttpRequest) -&gt; JsonResponse:\n    user = request.user\n    return JsonResponse({\n        \"email\": user.email,\n        \"first_name\": user.first_name,\n        \"last_name\": user.last_name,\n        \"username\": user.username,\n        \"picture\": user.microsoftssouser.picture_raw,\n        \"microsoft_id\": user.microsoftssouser.microsoft_id,\n        \"locale\": user.microsoftssouser.locale,\n    })\n</code></pre> <p>You can also import the model directly, like this:</p> <pre><code>from django_microsoft_sso.models import MicrosoftSSOUser\n\nmicrosoft_info = MicrosoftSSOUser.objects.get(user=user)\n</code></pre> <p>You can disable this model</p> <p>If you don't want to save this basic data in the database, you can disable the <code>MicrosoftSSOUser</code> model by setting the <code>MICROSOFT_SSO_SAVE_BASIC_MICROSOFT_INFO</code> configuration to <code>False</code> in your <code>settings.py</code> file.</p>"},{"location":"model/#about-microsoft-scopes","title":"About Microsoft Scopes","text":"<p>To retrieve this data, Django Microsoft SSO uses the following scope from Microsoft Graph reference:</p> <pre><code>MICROSOFT_SSO_SCOPES = [  # Microsoft default scope\n    \"User.ReadBasic.All\"\n]\n</code></pre> <p>You can change this scopes overriding the <code>MICROSOFT_SSO_SCOPES</code> setting in your <code>settings.py</code> file. But if you ask the user to authorize more scopes, this plugin will not save this additional data in the database. You will need to implement your own logic to save this data, calling Microsoft again. You can see an example here.</p> <p>The main goal here is simplicity</p> <p>The main goal of this plugin is to be simple to use as possible. But it is important to ask the user once for the scopes. That's why this plugin permits you to change the scopes, but will not save the additional data from it.</p>"},{"location":"model/#the-access-token","title":"The Access Token","text":"<p>To make login possible, Django Microsoft SSO needs to get an access token from Microsoft. This token is used to retrieve User info to get or create the user in the database. If you need this access token, you can get it inside the User Request Session, like this:</p> <pre><code>from django.contrib.auth.decorators import login_required\nfrom django.http import JsonResponse, HttpRequest\n\n@login_required\ndef retrieve_user_data(request: HttpRequest) -&gt; JsonResponse:\n    user = request.user\n    return JsonResponse({\n        \"email\": user.email,\n        \"first_name\": user.first_name,\n        \"last_name\": user.last_name,\n        \"username\": user.username,\n        \"picture\": user.microsoftssouser.picture_raw,\n        \"microsoft_id\": user.microsoftssouser.microsoft_id,\n        \"locale\": user.microsoftssouser.locale,\n        \"access_token\": request.session[\"microsoft_sso_access_token\"],\n    })\n</code></pre> <p>Saving the Access Token in User Session is disabled, by default, to avoid security issues. If you need to enable it, you can set the configuration <code>MICROSOFT_SSO_SAVE_ACCESS_TOKEN</code> to <code>True</code> in your <code>settings.py</code> file. Please make sure you understand how to secure your cookies before enabling this option.</p>"},{"location":"multiple/","title":"Using Multiple Social Logins","text":"<p>A special advanced case is when you need to log in from multiple social providers. In this case, each provider will have its own package which you need to install and configure. Currently, we support:</p> <ul> <li>Django Google SSO</li> <li>Django Microsoft SSO</li> <li>Django GitHub SSO</li> </ul>"},{"location":"multiple/#install-the-packages","title":"Install the Packages","text":"<p>Install the packages you need:</p> <pre><code>pip install django-google-sso django-microsoft-sso django-github-sso\n\n# Optionally install Stela to handle .env files\npip install stela\n</code></pre>"},{"location":"multiple/#add-package-to-django-project","title":"Add Package to Django Project","text":"<p>To add this package in your Django Project, please modify the <code>INSTALLED_APPS</code> in your <code>settings.py</code>:</p> <pre><code># settings.py\n\nINSTALLED_APPS = [\n    # other django apps\n    \"django.contrib.messages\",  # Need for Auth messages\n    \"django_github_sso\",  # Will show as first button in login page\n    \"django_google_sso\",\n    \"django_microsoft_sso\",\n]\n</code></pre> <p>Order matters</p> <p>The first package on list will be the first button in the login page.</p>"},{"location":"multiple/#add-secrets-to-env-file","title":"Add secrets to env file","text":"<pre><code># .env.local\nGOOGLE_SSO_CLIENT_ID=999999999999-xxxxxxxxx.apps.googleusercontent.com\nGOOGLE_SSO_CLIENT_SECRET=xxxxxx\nGOOGLE_SSO_PROJECT_ID=999999999999\n\nMICROSOFT_SSO_APPLICATION_ID=FOO\nMICROSOFT_SSO_CLIENT_SECRET=BAZ\n\nGITHUB_SSO_CLIENT_ID=BAR\nGITHUB_SSO_CLIENT_SECRET=FOOBAR\n</code></pre>"},{"location":"multiple/#setup-django-urls","title":"Setup Django URLs","text":"<p>Add the URLs of each provider to your <code>urls.py</code> file:</p> <pre><code>from django.urls import include, path\n\n\nurlpatterns += [\n    path(\n        \"github_sso/\",\n        include(\"django_google_sso.urls\", namespace=\"django_github_sso\"),\n    ),\n    path(\n        \"google_sso/\",\n        include(\"django_github_sso.urls\", namespace=\"django_google_sso\"),\n    ),\n        path(\n        \"microsoft_sso/\",\n        include(\"django_github_sso.urls\", namespace=\"django_microsoft_sso\"),\n    ),\n]\n</code></pre>"},{"location":"multiple/#setup-django-settings","title":"Setup Django Settings","text":"<p>Add the settings of each provider to your <code>settings.py</code> file:</p> <pre><code># settings.py\nfrom stela import env\n\n# Django Microsoft SSO\nMICROSOFT_SSO_ENABLED = True\nMICROSOFT_SSO_APPLICATION_ID = env.MICROSOFT_SSO_APPLICATION_ID\nMICROSOFT_SSO_CLIENT_SECRET = env.MICROSOFT_SSO_CLIENT_SECRET\nMICROSOFT_SSO_ALLOWABLE_DOMAINS = [\"contoso.com\"]\n\n# Django Google SSO\nGOOGLE_SSO_ENABLED = True\nGOOGLE_SSO_CLIENT_ID = env.GOOGLE_SSO_CLIENT_ID\nGOOGLE_SSO_PROJECT_ID = env.GOOGLE_SSO_PROJECT_ID\nGOOGLE_SSO_CLIENT_SECRET = env.GOOGLE_SSO_CLIENT_SECRET\nGOOGLE_SSO_ALLOWABLE_DOMAINS = [\"contoso.net\"]\n\n# Django GitHub SSO\nGITHUB_SSO_ENABLED = True\nGITHUB_SSO_CLIENT_ID = env.GITHUB_SSO_CLIENT_ID\nGITHUB_SSO_CLIENT_SECRET = env.GITHUB_SSO_CLIENT_SECRET\nGITHUB_SSO_ALLOWABLE_ORGANIZATIONS = [\"contoso\"]\n</code></pre> <p>The login page will look like this:</p> <p></p> <p>You can hide the login form</p> <p>If you want to show only the SSO buttons, you can hide the login form using the <code>SSO_SHOW_FORM_ON_ADMIN_PAGE</code> setting.</p> <pre><code># settings.py\n\nSSO_SHOW_FORM_ON_ADMIN_PAGE = False\n</code></pre>"},{"location":"multiple/#avoiding-duplicated-users","title":"Avoiding duplicated Users","text":"<p>Both Django GitHub SSO and Django Microsoft SSO can create users without an email address, comparing the User <code>username</code> field against the Azure User Principal Name or Github User Name. This can cause duplicated users if you are using either package.</p> <p>To avoid this, you can set the <code>MICROSOFT_SSO_UNIQUE_EMAIL</code> and <code>GITHUB_SSO_UNIQUE_EMAIL</code> settings to <code>True</code>, making these packages compare User <code>email</code> against Azure Mail field or Github Primary Email. Make sure your Azure Tenant and GitHub Organization users have registered emails.</p>"},{"location":"multiple/#the-django-e003w003-warning","title":"The Django E003/W003 Warning","text":"<p>If you are using multiple Django SSO projects, you will get a warning like this:</p> <pre><code>WARNINGS:\n?: (templates.E003) 'show_form' is used for multiple template tag modules: 'django_google_sso.templatetags.show_form', 'django_microsoft_sso.templatetags.show_form'\n?: (templates.E003) 'sso_tags' is used for multiple template tag modules: 'django_google_sso.templatetags.sso_tags', 'django_microsoft_sso.templatetags.sso_tags'\n</code></pre> <p>This is because both packages use the same template tags. To silence this warning, you can set the <code>SILENCED_SYSTEM_CHECKS</code> as per Django documentation:</p> <pre><code># settings.py\nSILENCED_SYSTEM_CHECKS = [\"templates.W003\"] # Or \"templates.E003\" for Django &lt;=5.0\n</code></pre> <p>But if you need to check the templates, you can use the <code>SSO_USE_ALTERNATE_W003</code> setting to use an alternate template tag. This alternate check will run the original check, but will not raise the warning for the Django SSO packages. To use this alternate check, you need to set both the Django Silence Check and <code>SSO_USE_ALTERNATE_W003</code>:</p> <pre><code># settings.py\n\nSILENCED_SYSTEM_CHECKS = [\"templates.W003\"]  # Will silence the original check\nSSO_USE_ALTERNATE_W003 = True  # Will run alternate check\n</code></pre> <p>The tags will be executed only once, per request, for the last installed package</p> <p>To avoid multiple executions for the <code>define_sso_providers</code> and <code>define_show_form</code> tags, these code will be executed once and the result will be cached on the request object. Due to django template loading mechanism, the tag's code from the last installed package will be the one executed. This means if you have multiple packages installed, only the last one will be executed. To avoid this, you can use the <code>sso_providers</code> and <code>show_admin_form</code> context variables to pass the values you want to show in the template.</p> <pre><code># views.py\nfrom django.shortcuts import render\nfrom django_microsoft_sso.template_tags import define_sso_providers, define_show_form\n\ndef my_login_view(request):\n    ...\n    sso_providers = define_sso_providers({\"context\": request})\n    show_admin_form = define_show_form({\"context\": request})\n\n    return render(\n        request,\n        \"my_login_template.html\",\n        {\"sso_providers\": sso_providers, \"show_admin_form\": show_admin_form},\n    )\n</code></pre>"},{"location":"multiple/#split-providers-between-admin-and-page-logins","title":"Split Providers between Admin and Page Logins","text":"<p>If you want to use different providers for Admin and Page logins, you may need to enable/disable providers per request. For example, suppose if you want to use both Django Google SSO and Django Microsoft SSO for Page login but only  Django Microsoft SSO for the Admin, you can add the respective <code>*_SSO_PAGES_ENABLED</code> and <code>*_SSO_ADMIN_ENABLED</code>, like this:</p> <pre><code># settings.py\n\n# Control globally - both Admin and Pages (default: True)\nMICROSOFT_SSO_ENABLED = True\nGOOGLE_SSO_ENABLED = True\n\n# Use Google SSO for Pages only\n# Always define both Admin and Pages settings\nGOOGLE_SSO_PAGES_ENABLED = True\nGOOGLE_SSO_ADMIN_ENABLED = False\n\n# Explicitly configure Google Settings\n# to make sure they cannot have Admin privileges\nGOOGLE_SSO_ALLOWABLE_DOMAINS = [\"*\"]\nGOOGLE_SSO_AUTO_CREATE_FIRST_SUPERUSER = False\nGOOGLE_SSO_STAFF_LIST = []\nGOOGLE_SSO_SUPERUSER_LIST = []\nGOOGLE_SSO_FAILED_URL = \"index\"\nGOOGLE_SSO_NEXT_URL = \"secret\"\n</code></pre> <p>You need to be explicit on these settings</p> <p>If you set <code>MICROSOFT_SSO_ADMIN_ENABLED = False</code> and do not set <code>MICROSOFT_SSO_PAGES_ENABLED</code>, the default value for <code>MICROSOFT_SSO_PAGES_ENABLED</code> is also <code>False</code>. This means Microsoft SSO will be disabled for both Admin and Page logins. You need to be explicit on these settings.</p>"},{"location":"pages/","title":"Using Django Microsoft SSO outside Django Admin","text":"<p>Django Microsoft SSO aims for simplicity, that's why the primary focus is on the Admin login logic. But this package can be used outside Django Admin, in a custom login page. To do so, you can follow the steps below.</p> <p>This is the Tip of the Iceberg</p> <p>In real-life projects, user customer login involves more than just a login button. You need to implement many features like OTP, Captcha, \"Recover Password\", \"Remember Me\", \"Login with Passkey\" etc. This documentation shows a simple implementation to demonstrate how to use Django Microsoft SSO outside Django Admin, but for more complex UX requisites, please check full solutions like django-allauth, or incremental solutions like django-otp, django-recaptcha, django-passkeys, etc.</p>"},{"location":"pages/#add-django-microsoft-sso-templates-to-your-login-page","title":"Add Django Microsoft SSO templates to your login page","text":"<p>Inside your login template, just add these two lines:</p> <ul> <li><code>{% include 'microsoft_sso/login_sso.html' %}</code> inside <code>&lt;body&gt;</code></li> <li><code>{% static 'django_microsoft_sso/microsoft_button.css' %}</code> inside <code>&lt;head&gt;</code></li> </ul>"},{"location":"pages/#login-template-example","title":"Login template example","text":"<pre><code>{% load static %}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n        &lt;title&gt;Page Login&lt;/title&gt;\n        &lt;link rel=\"stylesheet\" href=\"{% static 'django_google_sso/google_button.css' %}\"&gt;\n        &lt;link rel=\"stylesheet\" href=\"{% static 'django_microsoft_sso/microsoft_button.css' %}\"&gt;\n        &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css\" rel=\"stylesheet\"\n              integrity=\"sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7\" crossorigin=\"anonymous\"&gt;\n        &lt;style&gt;\n            body {\n                background-color: #f8f9fa;\n            }\n            .microsoft-login-btn, .google-login-btn, .github-login-btn {\n                padding: 6px 4px;\n                height: 36px;\n            }\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body class=\"container d-flex flex-column vh-100\"&gt;\n        &lt;div class=\"d-flex flex-column w-100\"&gt;\n            {% if messages %}\n                {% for message in messages %}\n                    &lt;div class=\"alert\n                                {% if message.tags == 'error' %}alert-danger{% else %}alert-{{ message.tags }}{% endif %}\" role=\"alert\"&gt;\n                        {{ message }}\n                    &lt;/div&gt;\n                {% endfor %}\n            {% endif %}\n        &lt;/div&gt;\n        &lt;div class=\"d-flex flex-column justify-content-center align-items-center flex-grow-1\"&gt;\n            &lt;div class=\"card p-4 d-flex align-items-center\" style=\"width: 22rem;\"&gt;\n                &lt;div class=\"h4\"&gt;Django Microsoft SSO&lt;/div&gt;\n                {% include 'google_sso/login_sso.html' %}\n                &lt;a href=\"{% url 'admin:index' %}\" class=\"mt-2\"&gt;Go to Admin&lt;/a&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>The <code>include</code> command will add the login button to your template for all django-sso installed in the project.</p>"},{"location":"pages/#define-per-request-parameters","title":"Define per-request parameters","text":"<p>In the case you need different behavior for the login to Admin and login to Django pages, you can define this using callables on the Django Microsoft SSO settings. For example:</p> Setting Login to Admin Login to Pages <code>MICROSOFT_SSO_ALLOWABLE_DOMAINS</code> <code>[\"example.com\"]</code> <code>[\"*\"]</code> <code>MICROSOFT_SSO_LOGIN_FAILED_URL</code> <code>\"admin:login\"</code> <code>\"index\"</code> <code>MICROSOFT_SSO_NEXT_URL</code> <code>\"admin:index\"</code> <code>\"secret\"</code> <code>MICROSOFT_SSO_SESSION_COOKIE_AGE</code> <code>3600</code> <code>86400</code> <code>MICROSOFT_SSO_STAFF_LIST</code> <code>[...]</code> <code>[]</code> <code>MICROSOFT_SSO_SUPERUSER_LIST</code> <code>[...]</code> <code>[]</code> <p>You can config almost all settings per request</p> <p>You can config different Microsoft credentials, Scopes, Default Locale, etc. Please check the Settings and Sites docs for more details.</p>"},{"location":"pages/#settings-logic-example","title":"Settings logic example","text":"<pre><code># settings.py\nfrom django_microsoft_sso.helpers import is_admin_path\n\n\ndef get_sso_config(request):\n    config = {\n        \"admin\": {\n            \"allowable_domains\": env.get_or_default(\"MICROSOFT_SSO_ALLOWABLE_DOMAINS\", []),\n            \"login_failed_url\": \"admin:login\",\n            \"next_url\": \"admin:index\",\n            \"session_cookie_age\": 3600,  # 1 hour - default\n            \"staff_list\": env.get_or_default(\"MICROSOFT_SSO_STAFF_LIST\", []),\n            \"superuser_list\": env.get_or_default(\"MICROSOFT_SSO_SUPERUSER_LIST\", []),\n            \"auto_create_first_superuser\": True,  # Create superuser on first eligible user login\n        },\n        \"pages\": {\n            \"allowable_domains\": [\"*\"],  # Allow all domains\n            \"login_failed_url\": \"index\",\n            \"next_url\": \"secret\",\n            \"session_cookie_age\": 86400,  # 24 hours\n            \"staff_list\": [],\n            \"superuser_list\": [],\n            \"auto_create_first_superuser\": False,\n        },\n    }\n    if is_admin_path(request):\n        logger.debug(\"Returning Admin SSO configuration\")\n        return config[\"admin\"]\n    else:\n        logger.debug(\"Returning Pages SSO configuration\")\n        return config[\"pages\"]\n\n\n# Configure settings as callables\nMICROSOFT_SSO_ALLOWABLE_DOMAINS = lambda request: get_sso_config(request)[\n    \"allowable_domains\"\n]\nMICROSOFT_SSO_AUTO_CREATE_FIRST_SUPERUSER = lambda request: get_sso_config(request)[\n    \"auto_create_first_superuser\"\n]\nMICROSOFT_SSO_STAFF_LIST = lambda request: get_sso_config(request)[\"staff_list\"]\nMICROSOFT_SSO_SUPERUSER_LIST = lambda request: get_sso_config(request)[\"superuser_list\"]\nMICROSOFT_SSO_NEXT_URL = lambda request: get_sso_config(request)[\"next_url\"]\nMICROSOFT_SSO_SESSION_COOKIE_AGE = lambda request: get_sso_config(request)[\n    \"session_cookie_age\"\n]\nMICROSOFT_SSO_LOGIN_FAILED_URL = lambda request: get_sso_config(request)[\"login_failed_url\"]\n</code></pre>"},{"location":"pages/#toggle-microsoft-sso-between-admin-and-page-logins","title":"Toggle Microsoft SSO between Admin and Page logins","text":"<p>Finally, if you want to toggle between Admin and Page login, you can enable/disable Microsoft SSO using the <code>MICROSOFT_SSO_PAGES_ENABLED</code> and <code>MICROSOFT_SSO_ADMIN_ENABLED</code>. For example, if you want to enable Microsoft SSO only for Page login:</p> <pre><code># settings.py\n\n# Enable or disable globally\nMICROSOFT_SSO_ENABLED = True\n\n# Enable or Disable per request\nMICROSOFT_SSO_ADMIN_ENABLED = False\nMICROSOFT_SSO_PAGES_ENABLED = True\n</code></pre> <p>How Package knows if the request is for Admin or Page login?</p> <p>The package uses the <code>is_admin_path</code> and <code>is_page_path</code> helpers to check if the <code>request.path</code> starts with the admin path. To find the admin path, the package uses the <code>SSO_ADMIN_ROUTE</code> setting (default: <code>admin:index</code>).</p> <pre><code># settings.py\nfrom django_microsoft_sso.helpers import is_admin_path, is_page_path\n\nSSO_ADMIN_ROUTE = \"admin:index\"  # Default admin route\n\nMICROSOFT_SSO_ENABLED = True\nMICROSOFT_SSO_ADMIN_ENABLED = is_admin_path  # Same as True\nMICROSOFT_SSO_PAGES_ENABLED = is_page_path  # Same as True\n</code></pre>"},{"location":"quick_setup/","title":"Quick Setup","text":""},{"location":"quick_setup/#setup-django-settings","title":"Setup Django Settings","text":"<p>To add this package in your Django Project, please modify the <code>INSTALLED_APPS</code> in your <code>settings.py</code>:</p> <pre><code># settings.py\n\nINSTALLED_APPS = [\n    # other django apps\n    \"django.contrib.messages\",  # Need for Auth messages\n    \"django_microsoft_sso\",  # Add django_microsoft_sso\n]\n</code></pre>"},{"location":"quick_setup/#setup-microsoft-entra-credentials","title":"Setup Microsoft Entra Credentials","text":"<p>To configure django-microsoft-sso, you will need to access Microsoft Administration Center pages for Entra and Azure services.</p>"},{"location":"quick_setup/#the-application-id","title":"The Application ID","text":"<p>First, go to Microsoft Entra Administration Center and navigate to App registrations page. You can use an existing Application, or create a new one. Then, in the Application Overview page, from Application you want to use, annotate his Application (client) ID.</p>"},{"location":"quick_setup/#the-application-client-secret","title":"The Application Client Secret","text":"<p>Then, click on select application, navigate to Certificate &amp; secrets link, and get the Client Secret Value from that page.</p> <p>With these information, please add the credentials in your settings.py:</p> <pre><code># settings.py\n\nMICROSOFT_SSO_APPLICATION_ID = \"your Application ID here\"\nMICROSOFT_SSO_CLIENT_SECRET = \"your Client Secret Value here\"\n</code></pre>"},{"location":"quick_setup/#setup-callback-uri","title":"Setup Callback URI","text":"<p>In Microsoft Console at Api -&gt; Credentials -&gt; Oauth2 Client, add the following Authorized Redirect URI: <code>https://your-domain.com/microsoft_sso/callback/</code> replacing <code>your-domain.com</code> with your real domain (and Port). For example, if you're running locally, you can use <code>http://localhost:8000/microsoft_sso/callback/</code>.</p> <p>Do not forget the trailing slash!</p>"},{"location":"quick_setup/#setup-auto-create-users","title":"Setup Auto-Create Users","text":"<p>The next option is to set up the auto-create users from Django Microsoft SSO. Only emails with the allowed domains will be created automatically. If the email is not in the allowed domains, the user will be redirected to the login page.</p> <pre><code># settings.py\n\nMICROSOFT_SSO_ALLOWABLE_DOMAINS = [\"contoso.com\"]\n</code></pre>"},{"location":"quick_setup/#setup-django-urls","title":"Setup Django URLs","text":"<p>And in your <code>urls.py</code> please add the Django-Microsoft-SSO views:</p> <pre><code># urls.py\n\nfrom django.urls import include, path\n\nurlpatterns = [\n    # other urlpatterns...\n    path(\n        \"microsoft_sso/\", include(\n            \"django_microsoft_sso.urls\",\n            namespace=\"django_microsoft_sso\"\n        )\n    ),\n]\n</code></pre>"},{"location":"quick_setup/#run-django-migrations","title":"Run Django migrations","text":"<p>Finally, run migrations</p> <pre><code>$ python manage.py migrate\n</code></pre> <p>And, that's it: Django Microsoft SSO is ready for use. When you open the admin page, you will see the \"Login with Microsoft\" button:</p> Light ModeDark Mode <p></p> <p></p> How about Django Admin skins, like Grappelli? <p>Django Microsoft SSO will works with any Django Admin skin which calls the original Django login template, like Grappelli, Django Jazzmin, Django Admin Interface and Django Jet Reboot.</p> <pre><code>If the skin uses his own login template, you will need create your own `admin/login.html` template to add both HTML from custom login.html from the custom package and from this library.\n</code></pre> <p>For the next pages, let's see each one of these steps with more details.</p>"},{"location":"settings/","title":"All Django Settings options","text":"Setting Description <code>MICROSOFT_SSO_ADMIN_ENABLED</code> Enable SSO only when allowed on Admin pages. Default: <code>None</code> <code>MICROSOFT_SSO_ALLOWABLE_DOMAINS</code> List of domains that will be allowed to create users. Default: <code>[]</code> <code>MICROSOFT_SSO_ALWAYS_UPDATE_USER_DATA</code> If true, update default user info from Microsoft data at every login. This will also make their password unusable. Otherwise, all of this happens only on create. Default: <code>False</code> <code>MICROSOFT_SSO_AUTHENTICATION_BACKEND</code> The authentication backend to use.  Default: <code>None</code> <code>MICROSOFT_SSO_AUTHORITY</code> A info that defines the token authority. You should set it with your tenant URL or AuthorityBuilder instance. Default: <code>None</code> <code>MICROSOFT_SSO_AUTO_CREATE_FIRST_SUPERUSER</code> If True, the first user that logs in will be created as superuser if no superuser exists in the database at all. Default: <code>False</code> <code>MICROSOFT_SSO_AUTO_CREATE_USERS</code> Enable or disable the auto-create users feature. Default: <code>True</code> <code>MICROSOFT_SSO_CALLBACK_DOMAIN</code> The netloc to be used on Callback URI. Default: <code>None</code> <code>MICROSOFT_SSO_CLIENT_ID</code> The Microsoft OAuth 2.0 Web Application Client ID. Default: <code>None</code> <code>MICROSOFT_SSO_CLIENT_SECRET</code> The Microsoft OAuth 2.0 Web Application Client Secret. Default: <code>None</code> <code>MICROSOFT_SSO_ENABLE_LOGS</code> Show Logs from the library. Default: <code>True</code> <code>MICROSOFT_SSO_ENABLE_MESSAGES</code> Show Messages using Django Messages Framework. Default: <code>True</code> <code>MICROSOFT_SSO_ENABLED</code> Enable or disable the plugin. Default: <code>True</code> <code>MICROSOFT_SSO_GRAPH_TIMEOUT</code> The timeout in seconds for the Microsoft Graph API requests. Default: <code>10</code> <code>MICROSOFT_SSO_LOGIN_FAILED_URL</code> The named url path that the user will be redirected to if an authentication error is encountered. Default: <code>admin:index</code> <code>MICROSOFT_SSO_LOGO_URL</code> The URL of the logo to be used on the login button. Default: <code>https://purepng.com/public/uploads/large/purepng.com-microsoft-logo-iconlogobrand-logoiconslogos-251519939091wmudn.png</code> <code>MICROSOFT_SSO_NEXT_URL</code> The named url path that the user will be redirected if there is no next url after successful authentication. Default: <code>admin:index</code> <code>MICROSOFT_SSO_PAGES_ENABLED</code> Enable SSO button injection on non-admin pages. Default: <code>None</code> <code>MICROSOFT_SSO_PRE_CREATE_CALLBACK</code> Callable for processing pre-create logic. Default: <code>django_microsoft_sso.hooks.pre_create_user</code> <code>MICROSOFT_SSO_PRE_LOGIN_CALLBACK</code> Callable for processing pre-login logic. Default: <code>django_microsoft_sso.hooks.pre_login_user</code> <code>MICROSOFT_SSO_PRE_VALIDATE_CALLBACK</code> Callable for processing pre-validate logic. Default: <code>django_microsoft_sso.hooks.pre_validate_user</code> <code>MICROSOFT_SSO_PROJECT_ID</code> The Microsoft OAuth 2.0 Project ID. Default: <code>None</code> <code>MICROSOFT_SSO_SAVE_ACCESS_TOKEN</code> Save the access token in the session. Default: <code>False</code> <code>MICROSOFT_SSO_SAVE_BASIC_MICROSOFT_INFO</code> Save basic Microsoft info on database. Default: <code>True</code> <code>MICROSOFT_SSO_SCOPES</code> The Microsoft OAuth 2.0 Scopes. Default: <code>[\"User.ReadBasic.All\"]</code> <code>MICROSOFT_SSO_SESSION_COOKIE_AGE</code> The age of the session cookie in seconds. Default: <code>3600</code> <code>MICROSOFT_SSO_SHOW_FAILED_LOGIN_MESSAGE</code> Show a message on browser when the user creation fails on database. Default: <code>False</code> <code>MICROSOFT_SSO_STAFF_LIST</code> List of emails that will be created as staff. Default: <code>[]</code> <code>MICROSOFT_SSO_SUPERUSER_LIST</code> List of emails that will be created as superuser. Default: <code>[]</code> <code>MICROSOFT_SSO_TEXT</code> The text to be used on the login button. Default: <code>Sign in with Microsoft</code> <code>MICROSOFT_SSO_TIMEOUT</code> The timeout in seconds for the Microsoft SSO authentication returns info, in minutes. Default: <code>10</code> <code>MICROSOFT_SSO_UNIQUE_EMAIL</code> When get or create a new user, check if the email already exists. Default: <code>False</code> <code>SSO_ADMIN_ROUTE</code> The admin index page route. Default: <code>admin:index</code> <code>SSO_SHOW_FORM_ON_ADMIN_PAGE</code> Show the form on the admin page. Default: <code>True</code> <code>SSO_USE_ALTERNATE_W003</code> Use alternate W003 warning. You need to silence original templates.E003 warning. Default: <code>False</code>"},{"location":"sites/","title":"Using Django Sites Framework","text":"<p>Django Microsoft SSO now supports the Django Sites Framework, allowing you to have different SSO configurations for different sites in your Django project.</p>"},{"location":"sites/#how-it-works","title":"How It Works","text":"<p>Most configuration settings in Django Microsoft SSO can now accept either a direct value or a callable function that receives the current request and returns the appropriate value for the current site.</p> <p>This means you can dynamically determine configuration values based on the current site being accessed, enabling scenarios like:</p> <ul> <li>Different Microsoft OAuth credentials per site</li> <li>Different user creation policies per site</li> <li>Different session timeouts per site</li> </ul>"},{"location":"sites/#setup","title":"Setup","text":"<ol> <li>First, ensure the Django Sites Framework is properly configured in your project:</li> </ol> <pre><code># settings.py\nINSTALLED_APPS = [\n    # ...\n    'django.contrib.sites',\n    'django_microsoft_sso',\n    # ...\n]\n\nSITE_ID = 1  # Default site ID\n</code></pre> <ol> <li> <p>Create your sites in the Django admin or via migrations.</p> </li> <li> <p>Configure Django Microsoft SSO settings as callables that return different values based on the current site:</p> </li> </ol> <pre><code># settings.py\nfrom django.contrib.sites.shortcuts import get_current_site\n\ndef get_client_id(request):\n    \"\"\"Return different client ID based on the current site.\"\"\"\n    site = get_current_site(request)\n\n    # Map site domains to client IDs\n    client_ids = {\n        'site.com': 'client-id-for-example-com',\n        'other-site.com': 'client-id-for-other-site',\n    }\n\n    return client_ids.get(site.domain, 'default-client-id')\n\n# Configure settings as callables\nMICROSOFT_SSO_CLIENT_ID = get_client_id\n</code></pre>"},{"location":"sites/#example-complete-site-specific-configuration","title":"Example: Complete Site-Specific Configuration","text":"<p>Here's a more comprehensive example showing how to configure multiple settings per site:</p> <pre><code># settings.py\nfrom django.contrib.sites.shortcuts import get_current_site\n\ndef get_site_config(request, config_key):\n    \"\"\"Get site-specific configuration.\"\"\"\n    site = get_current_site(request)\n\n    # Define configurations for each site\n    site_configs = {\n        'site.com': {\n            'client_id': 'client-id-for-example-com',\n            'client_secret': 'secret-for-example-com',\n            'project_id': 'project-id-for-example-com',\n            'auto_create_users': True,\n            'session_cookie_age': 3600,  # 1 hour\n            'allowable_domains': ['example.com', 'example.org'],\n        },\n        'other-site.com': {\n            'client_id': 'client-id-for-other-site',\n            'client_secret': 'secret-for-other-site',\n            'project_id': 'project-id-for-other-site',\n            'auto_create_users': False,\n            'session_cookie_age': 86400,  # 24 hours\n            'allowable_domains': ['other-site.com'],\n        }\n    }\n\n    # Get config for current site, or use defaults\n    site_config = site_configs.get(site.domain, {})\n    return site_config.get(config_key, None)\n\n# Configure settings as callables\nMICROSOFT_SSO_CLIENT_ID = lambda request: get_site_config(request, 'client_id')\nMICROSOFT_SSO_CLIENT_SECRET = lambda request: get_site_config(request, 'client_secret')\nMICROSOFT_SSO_PROJECT_ID = lambda request: get_site_config(request, 'project_id')\nMICROSOFT_SSO_AUTO_CREATE_USERS = lambda request: get_site_config(request, 'auto_create_users')\nMICROSOFT_SSO_SESSION_COOKIE_AGE = lambda request: get_site_config(request, 'session_cookie_age')\nMICROSOFT_SSO_ALLOWABLE_DOMAINS = lambda request: get_site_config(request, 'allowable_domains')\n</code></pre> <p>Unsupported Settings for Callables</p> <p>All settings support callable configuration, except the following:</p> <ul> <li><code>MICROSOFT_SSO_ENABLED</code></li> <li><code>MICROSOFT_SSO_ENABLE_LOGS</code></li> <li><code>SSO_USE_ALTERNATE_W003</code></li> </ul>"},{"location":"thanks/","title":"Thank you","text":"<p>Thank you for using this project. And for all the appreciation, patience and support.</p> <p>I really hope this project can make your life a little easier.</p> <p>Please feel free to check our other projects:</p> <ul> <li>stela: Easily manage project settings and secrets in any python project.</li> <li>django-google-sso: A Django app to enable Single Sign-On with Google Accounts.</li> <li>django-microsoft-sso: A Django app to enable Single Sign-On with Microsoft 365 Accounts.</li> <li>django-github-sso: A Django app to enable Single Sign-On with GitHub Accounts.</li> </ul>"},{"location":"thanks/#donating","title":"Donating","text":"<p>If you like to finance this project, please consider donating:</p> <p></p>"},{"location":"third_party_admins/","title":"Using Third Party Django Admins","text":"<p>Django has a great ecosystem, and many third-party apps are available to completely replace the default UI for Django Admin. We are trying to make Django Microsoft SSO compatible as much as possible with these third-party apps. We can divide these apps broadly into two categories: apps which use the original Django Admin login template and apps with custom login templates.</p> How can I know if the third app has a custom login template? <p>Check if the app code contains the <code>templates/admin/login.html</code> file. If the file exists, the app has a custom login template.</p>"},{"location":"third_party_admins/#apps-with-use-original-django-admin-login-template","title":"Apps with use original Django Admin login template","text":"<p>For these apps, Django Microsoft SSO will work out of the box. You don't need to do anything special to make it work.</p> <p>Some examples:</p> <ul> <li>Django Admin Interface</li> <li>Django Grappelli</li> <li>Django Jazzmin</li> <li>Django Jet Reboot</li> </ul>"},{"location":"third_party_admins/#apps-with-custom-login-template","title":"Apps with custom login template","text":"<p>For these apps, you will need to create your own <code>admin/login.html</code> template to add both HTML from the custom login.html from the custom package and from this library, using this basic guideline:</p>"},{"location":"third_party_admins/#create-a-custom-templatesadminloginhtml-template","title":"Create a custom <code>templates/admin/login.html</code> template","text":"<p>Suppose the <code>templates/admin/login.html</code> from the 3<sup>rd</sup> party app is using this structure:</p> <pre><code>{% extends \"third_app/base.html\" %}\n\n{% block my_form %}\n    &lt;form method=\"post\" action=\"{% url 'admin:login' %}\"&gt;\n        {% csrf_token %}\n        {{ form.as_p }}\n        &lt;input type=\"submit\" value=\"Log in\"&gt;\n{% endblock %}\n</code></pre> <p>Please add on your project the <code>templates/admin/login.html</code> template:</p> <pre><code>{% extends \"admin/login.html\" %}\n\n{% block my_form %} {# Use the name of the block from the third-party app #}\n    {{ block.super }} {# this will include the 3rd party app login.html content #}\n    {% include \"microsoft_sso/login_sso.html\" %} {# this will include the Microsoft SSO login button #}\n{% endblock %}\n</code></pre> <p>Now, let's add support to the <code>SSO_SHOW_FORM_ON_ADMIN_PAGE</code> option. To do this, update the code to include our <code>show_form</code> tag:</p> <pre><code>{% extends \"admin/login.html\" %}\n{% load show_form %}\n\n{% block my_form %} {# Use the name of the block from the third-party app #}\n    {% define_show_form as show_form %}\n        {% if show_form %}\n            {{ block.super }} {# this will include the 3rd party app login.html content #}\n        {% endif %}\n    {% include \"microsoft_sso/login_sso.html\" %} {# this will include the Microsoft SSO login button #}\n{% endblock %}\n</code></pre> <p>This is a basic example.</p> <p>In real cases, you will need to understand how to find the correct elements to hide, and/or how to correct positioning the SSO buttons on the 3<sup>rd</sup> party app layout. Use the real life example from <code>django-unfold</code> described below.</p> <p>Also, make sure you understand how Django works with Template inheritance and How to override templates.</p>"},{"location":"third_party_admins/#current-custom-login-apps-support","title":"Current Custom Login Apps support","text":"<p>To this date, Django Microsoft SSO provides support out of the box for these apps with custom login templates:</p> <ul> <li>Django Unfold</li> </ul> <p>For the Django Unfold we use this the code on our login template:</p> <pre><code>{% extends \"admin/login.html\" %}\n{% load static %}\n{% load sso_tags %}\n{% load show_form %}\n{% load i18n %}\n\n{% block extrastyle %}\n    {{ block.super }}\n    {% with sso_providers|default:None as sso_providers %}\n        {% if sso_providers is None %}\n            {% define_sso_providers as sso_providers %}\n        {% endif %}\n        {% for provider in sso_providers %}\n            &lt;link rel=\"stylesheet\" href=\"{{ provider.css_url }}\"&gt;\n        {% endfor %}\n    {% endwith %}\n{% endblock %}\n\n{# Default Django Admin Block #}\n{% block content %}\n    &lt;!--\n        You can pass a custom Show Form to this\n        template using the `show_admin_form` context variable.\n        If not provided, the template will use the default\n        `define_show_form` defined in the sso tags.\n    --&gt;\n    {% with show_admin_form|default:None as show_form %}\n        {% if show_form is None %}\n            {% define_show_form as show_form %}\n        {% endif %}\n        {% if show_form %}\n            {{ block.super }}\n        {% endif %}\n        {% include 'microsoft_sso/login_sso.html' %}\n    {% endwith %}\n{% endblock %}\n\n{# Django Unfold Admin Block #}\n{% block base %}\n    {{ block.super }}  {# Process HTML login elements from Django Unfold #}\n    {% include 'microsoft_sso/login_sso.html' %} {# Add Microsoft SSO HTML elements #}\n    &lt;script&gt;\n        {% with show_admin_form|default:None as show_form %}\n            {% if show_form is None %}\n                {% define_show_form as show_form %}\n            {% endif %}\n            {% if show_form %}\n                $(document).ready(function() {\n                    $(\".login-box\").insertAfter(\"#login-form\");\n                });\n            {% else %}\n                $(\"#login-form\").remove();\n                $(document).ready(function() {\n                    $(\".login-box\").insertAfter(\".font-semibold.mb-10\");\n                });\n            {% endif %}\n        {% endwith %}\n    &lt;/script&gt;\n{% endblock %}\n</code></pre> <p>And this is the CSS you can use to customize your login button (you will need to create your custom <code>static/django_microsoft_sso/microsoft_button.css/</code> to work):</p> <pre><code>/*\n\n  Please rename this file to microsoft_button.css to override works.\n  This CSS is compatible with Django Unfold CSS\n\n  login-btn\n  ---------------------------------\n  | --------------                 |\n  | | btn-logo   |    btn-label    |\n  | --------------                 |\n  ----------------------------------\n*/\n\n/* Login Button Area */\n.login-btn-area {\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        align-items: center;\n        width: 382px;\n}\n\n/* Microsoft Login Button */\n.microsoft-login-btn {\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    background-color: #9233e7;\n    border-radius: 6px;\n    padding: 2px;\n    margin-bottom: 20px;\n    width: 100%;\n    height: 38px;\n    font-family: 'Inter', sans-serif;\n    font-size: 14px;\n    font-weight: 600;\n}\n\n/* Microsoft Login Button Hover */\n.microsoft-login-btn:hover {\n    background-color: rgba(167, 167, 167, 0.56);\n    border: 1px solid rgba(167, 167, 167, 0.56);\n}\n\n/* Microsoft Login Button Remove Decoration */\n.microsoft-login-btn a {\n    text-decoration: none;\n}\n\n/* Microsoft Login Button Logo Area */\n.microsoft-btn-logo {\n    display: flex;\n    justify-content: center;\n    align-content: center;\n    padding: 4px;\n}\n\n\n/* Microsoft Login Button Label Area */\n.microsoft-btn-label {\n    color: #ffffff;\n    margin-top: -1px;\n    width: 100%;\n    text-align: center;\n    padding: 0 10px;\n}\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":""},{"location":"troubleshooting/#common-questions","title":"Common questions:","text":"Admin Message: State Mismatched. Time expired? <p>This error occurs when the user is redirected to the Microsoft login page and then returns to the Django login page but original state are not found or session was expired. Please check if the browser has the anonymous session created by Django.</p> My callback URL is http://example.com/microsoft_sso/callback/ but my project is running at http://localhost:8000 <p>This error occurs because your Project is using the Django Sites Framework and the current site is not configured correctly. Please make sure that the current site is configured for your needs or, alternatively, use the <code>MICROSOFT_SSO_CALLBACK_DOMAIN</code> setting.</p> There's too much information on logs and messages from this app. <p>You can disable the logs using the <code>MICROSOFT_SSO_ENABLE_LOGS</code> setting and the messages using the <code>MICROSOFT_SSO_ENABLE_MESSAGES</code> setting.</p> I am getting Authorization Code not received from SSO when attempting to login. <p>Ensure you have a multi-tenant app registration, or if you wish to keep single-tenant you can adjust <code>MICROSOFT_SSO_AUTHORITY</code> as noted here</p> System goes looping to admin after login. <p>This is because the user data was received from Microsoft, but the user was not created in the database or is not active. To see these errors please check the logs or enable the option <code>MICROSOFT_SSO_SHOW_FAILED_LOGIN_MESSAGE</code> to see failed login messages on browser. Please, make note these messages can be used on exploit attacks.</p> <p>??? question \"When I config a custom Authentication Backend using MICROSOFT_SSO_AUTHENTICATION_BACKEND, the lib stops to login, without errors or logs.     This is because the value of <code>MICROSOFT_SSO_AUTHENTICATION_BACKEND</code> is not a valid authentication backend import path.     Please check the value of this setting and make sure it is a valid import path to a Django authentication backend.</p> When using one package for Admin and another for Pages, the user can enter in Admin, even if I configure the Pages SSO to not give any admin rights <p>Please check if the user is not already a staff or superuser in the database, especially if you're using the <code>MICROSOFT_SSO_UNIQUE_EMAIL</code> and <code>GITHUB_SSO_UNIQUE_EMAIL</code> options. If the user is already a staff or superuser, he will be able to enter in Admin, even if the SSO package for Pages does not give him any admin rights.</p> Got a \"KeyError: 'NAME'\" error after set SSO_USE_ALTERNATE_W003 <p>If you get a <code>KeyError: 'NAME'</code> error, please set a <code>NAME</code> in <code>TEMPLATES</code> at <code>settings.py</code>:</p> <pre><code># settings.py\n\nTEMPLATES = [\n    {\n        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n        \"NAME\" : \"default\",  # &lt;-- Add name here\n        \"DIRS\": [BASE_DIR / \"templates\"],\n        \"APP_DIRS\": True,\n        \"OPTIONS\": {\n            \"context_processors\": [\n                \"django.template.context_processors.debug\",\n                \"django.template.context_processors.request\",\n                \"django.contrib.auth.context_processors.auth\",\n                \"django.contrib.messages.context_processors.messages\",\n            ],\n        },\n    },\n]\n</code></pre> Got this error when migrating: 'The model User is already registered with 'core.MicrosoftSSOUserAdmin' <p>This is because you're already define a custom User model and admin in your project. You need to extended the existing user model unregistering your current User Admin class and add manually the <code>MicrosoftSSOUserAdmin</code> in your custom class. You can use the <code>get_current_user_and_admin</code> helper as explained here (the recommended action), or alternately, you can add the <code>django-microsoft-sso</code> at the end of your <code>INSTALLED_APPS</code> list.</p>"},{"location":"troubleshooting/#example-app","title":"Example App","text":"<p>To test this library please check the <code>Example App</code> provided here.</p>"},{"location":"troubleshooting/#not-working","title":"Not working?","text":"<p>Don't panic. Get a towel and, please, open an issue.</p>"},{"location":"urls/","title":"Setup Django URLs","text":"<p>The base configuration for Django URLs is the same we have described as before: <pre><code># urls.py\n\nfrom django.urls import include, path\n\nurlpatterns = [\n    # other urlpatterns...\n    path(\n        \"microsoft_sso/\", include(\n            \"django_microsoft_sso.urls\",\n            namespace=\"django_microsoft_sso\"\n        )\n    ),\n]\n</code></pre> You can change the initial Path - <code>microsoft_sso/</code> - to whatever you want - just remember to change it on the Web Platform of your Registered Application as well.</p>"},{"location":"urls/#overriding-the-login-view-or-path","title":"Overriding the Login view or Path","text":"<p>If you need to override the login view, or just the path, please add on the new view/class the Django SSO Admin login template:</p> <pre><code>from django.contrib.auth.views import LoginView\nfrom django.urls import path\n\n\nurlpatterns = [\n    # other urlpatterns...\n    path(\n        \"accounts/login/\",\n        LoginView.as_view(\n            # The modified form with Microsoft button\n            template_name=\"microsoft_sso/login.html\"\n        ),\n    ),\n]\n</code></pre> <p>or you can use a complete custom class:</p> <pre><code>from django.contrib.auth.views import LoginView\n\n\nclass MyLoginView(LoginView):\n    template_name = \"microsoft_sso/login.html\"\n</code></pre>"},{"location":"users/","title":"Auto Creating Users","text":"<p>Django Microsoft SSO can automatically create users from Microsoft SSO authentication. To enable this feature, you need to set the <code>MICROSOFT_SSO_ALLOWABLE_DOMAINS</code> setting in your <code>settings.py</code>, with a list of domains that will be allowed to create. For example, if any user with a gmail account can sign in, you can set:</p> <pre><code># settings.py\nMICROSOFT_SSO_ALLOWABLE_DOMAINS = [\"contoso.com\"]\n</code></pre> <p>To allow everyone to register, you can use \"*\" as the value (but beware the security implications):</p> <pre><code># Use \"*\" to add all users\nMICROSOFT_SSO_ALLOWABLE_DOMAINS = [\"*\"]\n</code></pre>"},{"location":"users/#disabling-the-auto-create-users","title":"Disabling the auto-create users","text":"<p>You can disable the auto-create users feature by setting the <code>MICROSOFT_SSO_AUTO_CREATE_USERS</code> setting to <code>False</code>:</p> <pre><code>MICROSOFT_SSO_AUTO_CREATE_USERS = False\n</code></pre> <p>You can also disable the plugin completely:</p> <pre><code>MICROSOFT_SSO_ENABLED = False\n</code></pre>"},{"location":"users/#giving-permissions-to-auto-created-users","title":"Giving Permissions to Auto-Created Users","text":"<p>If you are using the auto-create users feature, you can give permissions to the users that are created automatically. To do this, you can set the following options in your <code>settings.py</code>:</p> <pre><code># List of emails or user principal names that will be created as staff\nMICROSOFT_SSO_STAFF_LIST = [\"my-email@contoso.com\"]\n\n# List of emails or user principal names that will be created as superuser\nMICROSOFT_SSO_SUPERUSER_LIST = [\"another-email@contoso.com\"]\n\n# If True, the first user that checks in will be created as superuser\n# if no superuser exists in the database at all\nMICROSOFT_SSO_AUTO_CREATE_FIRST_SUPERUSER = True\n</code></pre> <p>For staff user creation only, you can add all users using \"*\" as the value:</p> <pre><code># Use \"*\" to add all users as staff\nMICROSOFT_SSO_STAFF_LIST = [\"*\"]\n</code></pre>"},{"location":"users/#fine-tuning-validation-before-user-validation","title":"Fine-tuning validation before user validation","text":"<p>If you need to do some custom validation before user is validated, you can set the <code>MICROSOFT_SSO_PRE_VALIDATE_CALLBACK</code> setting to import a custom function that will be called before the user is created. This function will receive two arguments: the <code>ms_gragh_info</code> dict from User Graph API response and <code>request</code> objects.</p> <pre><code># myapp/hooks.py\ndef pre_validate_user(ms_graph_info, request):\n    # Check some info from ms_graph_info and/or request\n    return True  # The user can be created\n</code></pre> <p>Please note, even if this function returns <code>True</code>, the user can be denied if their email is not valid.</p>"},{"location":"users/#fine-tuning-user-info-before-user-creation","title":"Fine-tuning user info before user creation","text":"<p>If you need to do some processing before user is created, you can set the <code>MICROSOFT_SSO_PRE_CREATE_CALLBACK</code> setting to import a custom function that will be called before the user is created. This function will receive two arguments: the <code>ms_user_info</code> dict from Graph User API and <code>request</code> objects.</p> <p>You can add custom fields to the user model here</p> <p>The <code>pre_create_callback</code> function can return a dictionary with the fields and values that will be passed to <code>User.objects.create()</code> as the <code>defaults</code> argument. This means you can add custom fields to the user model here or change default values for some fields, like <code>username</code>.</p> <p>If not defined, the field <code>username</code> is always the User Principal Name.</p> <p>You can't change the fields: <code>first_name</code>, <code>last_name</code>, <code>email</code> and <code>password</code> using this callback. These fields are always passed to <code>User.objects.create()</code> with the values from Graph API and the password is always unusable.</p> <pre><code>import arrow\n\ndef pre_create_callback(ms_info, request) -&gt; dict | None:\n    \"\"\"Callback function called before user is created.\n\n    return: dict content to be passed to\n            User.objects.create() as `defaults` argument.\n            If not informed, field `username` is always\n            the user principal name.\n    \"\"\"\n\n    user_key = ms_info[\"mail\"].split(\"@\")[0]\n    user_id = ms_info[\"id\"].replace(\"-\", \"\")\n\n    username = f\"{user_key}_{user_id}\"\n\n    return {\n        \"username\": username,\n        \"date_joined\": arrow.utcnow().shift(days=-1).datetime,\n    }\n</code></pre>"},{"location":"users/#fine-tuning-users-before-login","title":"Fine-tuning users before login","text":"<p>If you need to do some processing after user is created or retrieved, but before the user is logged in, you can set the <code>MICROSOFT_SSO_PRE_LOGIN_CALLBACK</code> setting to import a custom function that will be called before the user is logged in. This function will receive two arguments: the <code>user</code> and <code>request</code> objects.</p> <pre><code># myapp/hooks.py\ndef pre_login_user(user, request):\n    # Do something with the user\n    pass\n\n# settings.py\nMICROSOFT_SSO_PRE_LOGIN_CALLBACK = \"myapp.hooks.pre_login_user\"\n</code></pre> <p>Please remember this function will be invoked only if a user exists, and if it is active. In other words, if the user is eligible for login.</p> <p>You can add your hooks to customize all steps:</p> <ul> <li><code>MICROSOFT_SSO_PRE_VALIDATE_CALLBACK</code>: Run before the user is validated.</li> <li><code>MICROSOFT_SSO_PRE_CREATE_CALLBACK</code>: Run before the user is created.</li> <li><code>MICROSOFT_SSO_PRE_LOGIN_CALLBACK</code>: Run before the user is logged in.</li> </ul> <p>Be careful with these options</p> <p>The idea here is to make your life easier, especially when testing. But if you are not careful, you can give permissions to users that you don't want, or even worse, you can give permissions to users that you don't know. So, please, be careful with these options.</p> <p>For the last step, we will look at the Django URLs.</p>"}]}